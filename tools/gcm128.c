#include "mc.h"
#include "mc_gcm.h"

static MC_NORETURN void gcm_usage(const char *argv0) {
	mc_die_usage(argv0, "gcm128 --nist-sp800-38d-tc3");
}

static void hex_encode(const mc_u8 *in, mc_usize in_len, char *out, mc_usize out_cap) {
	static const char hex[] = "0123456789abcdef";
	if (out_cap < in_len * 2u + 1u) return;
	for (mc_usize i = 0; i < in_len; i++) {
		mc_u8 b = in[i];
		out[i * 2u + 0u] = hex[(b >> 4) & 0xFu];
		out[i * 2u + 1u] = hex[b & 0xFu];
	}
	out[in_len * 2u] = 0;
}

__attribute__((used)) int main(int argc, char **argv, char **envp) {
	(void)envp;
	const char *argv0 = (argc > 0 && argv && argv[0]) ? argv[0] : "gcm128";
	if (argc != 2 || !argv[1]) gcm_usage(argv0);
	if (!mc_streq(argv[1], "--nist-sp800-38d-tc3")) gcm_usage(argv0);

	// NIST SP 800-38D, Test Case 3 (commonly cited example).
	static const mc_u8 key[16] = {
		0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08,
	};
	static const mc_u8 iv[12] = {
		0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,0xde,0xca,0xf8,0x88,
	};
	static const mc_u8 pt[64] = {
		0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
		0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
		0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
		0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39,0x1a,0xaf,0xd2,0x55,
	};
	static const mc_u8 exp_ct[64] = {
		0x42,0x83,0x1e,0xc2,0x21,0x77,0x74,0x24,0x4b,0x72,0x21,0xb7,0x84,0xd0,0xd4,0x9c,
		0xe3,0xaa,0x21,0x2f,0x2c,0x02,0xa4,0xe0,0x35,0xc1,0x7e,0x23,0x29,0xac,0xa1,0x2e,
		0x21,0xd5,0x14,0xb2,0x54,0x66,0x93,0x1c,0x7d,0x8f,0x6a,0x5a,0xac,0x84,0xaa,0x05,
		0x1b,0xa3,0x0b,0x39,0x6a,0x0a,0xac,0x97,0x3d,0x58,0xe0,0x91,0x47,0x3f,0x59,0x85,
	};
	static const mc_u8 exp_tag[16] = {
		0x4d,0x5c,0x2a,0xf3,0x27,0xcd,0x64,0xa6,0x2c,0xf3,0x5a,0xbd,0x2b,0xa6,0xfa,0xb4,
	};

	mc_u8 ct[64];
	mc_u8 tag[16];
	if (mc_aes128_gcm_encrypt(key, iv, MC_NULL, 0, pt, sizeof(pt), ct, tag) != 0) return 1;
	if (mc_memcmp(ct, exp_ct, sizeof(ct)) != 0) return 2;
	if (mc_memcmp(tag, exp_tag, sizeof(tag)) != 0) return 3;

	mc_u8 rt[64];
	if (mc_aes128_gcm_decrypt(key, iv, MC_NULL, 0, ct, sizeof(ct), tag, rt) != 0) return 4;
	if (mc_memcmp(rt, pt, sizeof(pt)) != 0) return 5;

	char ct_hex[64 * 2 + 1];
	char tag_hex[16 * 2 + 1];
	hex_encode(ct, sizeof(ct), ct_hex, sizeof(ct_hex));
	hex_encode(tag, sizeof(tag), tag_hex, sizeof(tag_hex));

	(void)mc_write_str(1, "ct ");
	(void)mc_write_str(1, ct_hex);
	(void)mc_write_all(1, "\n", 1);
	(void)mc_write_str(1, "tag ");
	(void)mc_write_str(1, tag_hex);
	(void)mc_write_all(1, "\n", 1);
	return 0;
}
